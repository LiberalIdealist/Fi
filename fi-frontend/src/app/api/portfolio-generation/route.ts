import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/prisma";
import OpenAI from 'openai';

// Initialize OpenAI client
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Fetch the user's profile with all financial data
    const user = await prisma.user.findUnique({
      where: { email: session.user.email },
      include: {
        financialProfile: {
          include: {
            financialData: true,
            documentAnalyses: {
              take: 5,
              orderBy: { createdAt: 'desc' }
            }
          }
        }
      },
    });

    if (!user || !user.financialProfile) {
      return NextResponse.json(
        { error: "Financial profile not found. Complete the questionnaire first." },
        { status: 404 }
      );
    }

    // Get risk profile and insights generated by Gemini
    const profileData = user.financialProfile;
    const financialData = profileData.financialData;
    
    // Format document analyses
    const documentInsights = profileData.documentAnalyses.map(analysis => {
      try {
        // Try to parse the analysis content as JSON
        const contentObj = JSON.parse(analysis.analysisContent.match(/\{[\s\S]*\}/)?.[0] || "{}");
        return {
          date: analysis.createdAt,
          insights: contentObj.insights || [],
          documentType: contentObj.documentType || "Unknown",
          metrics: contentObj.metrics || {}
        };
      } catch (e) {
        return {
          date: analysis.createdAt,
          insights: [],
          documentType: "Unknown",
          metrics: {}
        };
      }
    });

    // Create a comprehensive financial profile for the prompt
    const financialDataForPrompt = formatFinancialDataForPrompt(financialData);
    const documentInsightsForPrompt = formatDocumentInsightsForPrompt(documentInsights);
    
    // System prompt for ChatGPT to act as a financial advisor
    const systemPrompt = `
      You are a professional financial advisor specializing in Indian markets.
      You have expertise in stocks, mutual funds, fixed deposits, and insurance products available in India.
      Your task is to create a comprehensive portfolio recommendation based on the user's financial profile,
      questionnaire responses, and data extracted from their financial documents.
      
      Focus on providing practical, actionable financial advice suitable for the Indian market context.
      Consider current market conditions in India, taxation implications, and the user's risk profile.
      
      Generate a detailed, personalized portfolio that includes:
      
      1. Fixed Deposits (FDs): Recommend optimal allocation, duration, and specific banks if appropriate
      2. Stocks: Suggest 5-7 Indian stocks across different sectors with allocation percentages
      3. Mutual Funds: Recommend allocation across debt, hybrid and equity funds with specific fund names
      4. Insurance: Suggest optimal health, life, and term insurance coverage
      
      Then provide a detailed SWOT analysis (Strengths, Weaknesses, Opportunities, Threats) for this portfolio.
      
      Format your response as structured JSON with these sections:
      {
        "summary": "Brief summary of recommendations",
        "monthlyInvestment": number (recommended monthly investment amount in rupees),
        "emergencyFund": number (recommended emergency fund in rupees),
        "fixedDeposits": {"allocation": number(percent), "duration": string, "notes": string},
        "stocks": [{"name": string, "ticker": string, "allocation": number(percent), "rationale": string}],
        "mutualFunds": {
          "debt": [{"name": string, "allocation": number(percent), "risk": string}],
          "hybrid": [{"name": string, "allocation": number(percent), "risk": string}],
          "equity": [{"name": string, "allocation": number(percent), "risk": string}]
        },
        "insurance": {
          "health": {"coverAmount": number, "premium": number, "notes": string},
          "term": {"coverAmount": number, "premium": number, "notes": string},
          "life": {"coverAmount": number, "premium": number, "notes": string}
        },
        "swotAnalysis": {
          "strengths": [string],
          "weaknesses": [string],
          "opportunities": [string],
          "threats": [string]
        },
        "marketConditions": string,
        "disclaimer": string
      }
      
      Return ONLY the JSON without any additional text or explanation.
    `;

    // User prompt with all financial information
    const userPrompt = `
      Generate a portfolio recommendation based on this comprehensive financial profile:
      
      ## User Profile
      - Name: ${user.name || "Anonymous"}
      - Risk Score: ${profileData.riskScore || "Unknown"}/10
      - Financial Summary: ${profileData.financialSummary || "Not available"}
      
      ## Questionnaire Responses
      ${JSON.stringify(profileData.responses, null, 2)}
      
      ## Gemini Financial Analysis Insights
      ${JSON.stringify(profileData.geminiInsights, null, 2)}
      
      ## Financial Data from Documents
      ${financialDataForPrompt}
      
      ## Recent Document Analysis Insights
      ${documentInsightsForPrompt}
      
      ## Additional Instructions
      - If there are inconsistencies between questionnaire responses and document analysis, prioritize the document analysis as it represents actual financial behavior.
      - Consider the user's risk score when allocating between equity and debt instruments.
      - Suggest realistic monthly investment amount based on income and expenses.
      - Recommend specific mutual funds available in India by name.
    `;

    // Call ChatGPT API
    const chatResponse = await openai.chat.completions.create({
      model: "gpt-4-turbo",
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: userPrompt }
      ],
      temperature: 0.7,
    });

    // Get the response text
    const portfolioText = chatResponse.choices[0]?.message?.content || "";
    
    // Extract JSON from response
    const jsonMatch = portfolioText.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      return NextResponse.json({ error: "Failed to generate portfolio recommendations" }, { status: 500 });
    }

    const portfolioData = JSON.parse(jsonMatch[0]);

    // Store recommendation in Prisma
    let portfolioRec = await prisma.portfolioRecommendation.findUnique({
      where: { profileId: profileData.id }
    });

    if (portfolioRec) {
      // Update existing recommendation
      portfolioRec = await prisma.portfolioRecommendation.update({
        where: { id: portfolioRec.id },
        data: {
          fixedDeposits: portfolioData.fixedDeposits,
          stocks: portfolioData.stocks,
          mutualFunds: portfolioData.mutualFunds,
          insurance: portfolioData.insurance,
          swotAnalysis: portfolioData.swotAnalysis,
          monthlyInvestment: portfolioData.monthlyInvestment,
          emergencyFund: portfolioData.emergencyFund,
          marketConditions: portfolioData.marketConditions,
          generationPrompt: userPrompt,
          updatedAt: new Date()
        }
      });
    } else {
      // Create new recommendation
      portfolioRec = await prisma.portfolioRecommendation.create({
        data: {
          profileId: profileData.id,
          fixedDeposits: portfolioData.fixedDeposits,
          stocks: portfolioData.stocks,
          mutualFunds: portfolioData.mutualFunds,
          insurance: portfolioData.insurance,
          swotAnalysis: portfolioData.swotAnalysis,
          monthlyInvestment: portfolioData.monthlyInvestment,
          emergencyFund: portfolioData.emergencyFund,
          marketConditions: portfolioData.marketConditions,
          generationPrompt: userPrompt
        }
      });
    }

    return NextResponse.json({
      success: true,
      portfolio: portfolioData
    });

  } catch (error) {
    console.error("Error generating portfolio:", error);
    return NextResponse.json({ error: "Failed to generate portfolio" }, { status: 500 });
  }
}

// Format financial data for the prompt
function formatFinancialDataForPrompt(financialData: any): string {
  if (!financialData) {
    return "No detailed financial data available from documents.";
  }

  return `
    ### Income
    - Monthly Income: ${formatCurrency(financialData.monthlyIncome)}
    - Annual Income: ${formatCurrency(financialData.annualIncome)}
    - Income Stability: ${financialData.incomeStability || 'Unknown'}
    
    ### Expenses
    - Monthly Spending: ${formatCurrency(financialData.monthlySpending)}
    - Annual Spending: ${formatCurrency(financialData.annualSpending)}
    - Top Expenses: ${formatExpenses(financialData.topExpenses)}
    
    ### Savings & Assets
    - Current Savings: ${formatCurrency(financialData.savings)}
    - Savings Rate: ${formatPercentage(financialData.savingsRate)}
    - Emergency Fund: ${financialData.emergencyFundMonths ? `${financialData.emergencyFundMonths.toFixed(1)} months` : 'Unknown'}
    - Investments: ${formatInvestments(financialData.investments)}
    
    ### Debt & Liabilities
    - Total Debt: ${formatCurrency(financialData.totalDebt)}
    - Debt-to-Income Ratio: ${formatRatio(financialData.debtToIncomeRatio)}
    - Monthly EMI: ${formatCurrency(financialData.emi)}
    - Loans: ${formatLoans(financialData.loans)}
    - Credit Cards: ${formatCreditCards(financialData.creditCards)}
    
    ### Financial Health
    - Net Worth: ${formatCurrency(financialData.netWorth)}
    - Data Completeness: ${financialData.dataCompleteness ? `${financialData.dataCompleteness.toFixed(0)}%` : 'Unknown'}
  `;
}

// Format document insights for the prompt
function formatDocumentInsightsForPrompt(insights: any[]): string {
  if (!insights || insights.length === 0) {
    return "No document analysis insights available.";
  }

  return insights.map(doc => `
    ### ${doc.documentType} (${formatDate(doc.date)})
    ${doc.insights.map((insight: string) => `- ${insight}`).join('\n')}
    
    Key Metrics:
    ${formatMetrics(doc.metrics)}
  `).join('\n\n');
}

// Helper formatting functions
function formatCurrency(amount: number | null | undefined): string {
  if (amount == null) return 'Not available';
  return `â‚¹${amount.toLocaleString('en-IN')}`;
}

function formatPercentage(value: number | null | undefined): string {
  if (value == null) return 'Not available';
  return `${(value * 100).toFixed(1)}%`;
}

function formatRatio(value: number | null | undefined): string {
  if (value == null) return 'Not available';
  return value.toFixed(2);
}

function formatDate(date: Date | string): string {
  if (!date) return 'Unknown date';
  const d = new Date(date);
  return d.toISOString().split('T')[0];
}

function formatExpenses(expenses: any[] | null | undefined): string {
  if (!expenses || !Array.isArray(expenses) || expenses.length === 0) return 'None available';
  
  return expenses.slice(0, 3).map(exp => 
    `${exp.category || exp.description}: ${formatCurrency(exp.amount)}`
  ).join(', ');
}

function formatInvestments(investments: any[] | null | undefined): string {
  if (!investments || !Array.isArray(investments) || investments.length === 0) return 'None available';
  
  return investments.map(inv => 
    `${inv.type}: ${formatCurrency(inv.value)}`
  ).join(', ');
}

function formatLoans(loans: any[] | null | undefined): string {
  if (!loans || !Array.isArray(loans) || loans.length === 0) return 'None available';
  
  return loans.map(loan => 
    `${loan.type} (${formatCurrency(loan.outstandingAmount)}, ${loan.interestRate}%)`
  ).join(', ');
}

function formatCreditCards(cards: any[] | null | undefined): string {
  if (!cards || !Array.isArray(cards) || cards.length === 0) return 'None available';
  
  return cards.map(card => 
    `${card.issuer || 'Card'}: ${formatCurrency(card.outstandingAmount)} / ${formatCurrency(card.creditLimit)}`
  ).join(', ');
}

function formatMetrics(metrics: any): string {
  if (!metrics || typeof metrics !== 'object') return 'No metrics available';
  
  return Object.entries(metrics)
    .filter(([_, value]) => value !== null && value !== undefined)
    .map(([key, value]) => {
      if (typeof value === 'number') {
        return `${formatKey(key)}: ${formatCurrency(value as number)}`;
      }
      return `${formatKey(key)}: ${value}`;
    }).join('\n');
}

function formatKey(key: string): string {
  return key
    .replace(/([A-Z])/g, ' $1')
    .replace(/^./, str => str.toUpperCase());
}